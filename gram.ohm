SPV {

Program
    = (TypeDefine | VarDefine | Function)*

TypeDefine
    = "type" Type "=" "(" Parameters ")" ";" 

Type
    = name

Parameter
    = name ":" Type

Parameters
    = ListOf<Parameter, ",">

VarDefine
    =  ("var"|"let"|"in"|"out"|"uniform") name ":" Type ";"

Function
    = ("fn"|"function") name "(" Parameters ")" ("->" Type)? Expression

intNumber
    = digit+ (~("."|digit))                    -- decNumber
    | "0x" hexDigit+ (~hexDigit)               -- hexNumber
    | "0o" ("0".."7")+ (~("0".."7"))           -- octNumber
    | "0b" ("0".."1")+ (~("0".."1"))           -- binNumber

floatNumber
    = digit* "." digit* (~digit)                       -- floatNumber
    | digit+ ("." digit*)? ("e"|"E") digit+ (~digit)   -- floatSciNumber

generalNumber
    = intNumber                                -- intNumber
    | floatNumber                              -- floatNumebr

number
    = floatNumber ~("f")                       -- double
    | intNumber ~("f")                         -- int
    | generalNumber "f"                        -- float

keyword
    = "if"
    | "else"
    | "for"
    | "while"
    | "do"
    | "break"
    | "continue"
    | "return"

name
    = ~keyword (letter | "_") (alnum | "_")*

Expression
    = AssignExpression                                                      -- derive

Statement
    = "if" "(" Expression ")" Expression ("else" Expression)?               -- ifState
    | "for" "(" Expression ";" Expression ";" Expression ")" Expression     -- forState
    | "while" "(" Expression ")" Expression                                 -- whileState
    | "do" Expression "while" "(" Expression ")"                            -- composeWhileState
    | "break"                                                               -- breakState
    | "continue"                                                            -- continueState
    | "return" Expression                                                   -- returnState
    | ";"                                                                   -- semiclon

PrimaryExpression
    = name                                                                  -- variableLiteral
    | number                                                                -- numberLiteral
    | "{" Expression* "}"                                                   -- multiExpr
    | "(" ListOf<Expression, ","> ")"                                       -- tupleState
    | "[" ListOf<Expression, ","> "]"                                       -- arrayState
    | Statement                                                             -- statement

PropertyExpression
    = PrimaryExpression "[" Expression "]"                                  -- getAddress
    | PrimaryExpression "(" ListOf<Expression, ","> ")"                     -- callFunc
    | PrimaryExpression "." name                                            -- getMember
    | PrimaryExpression                                                     -- derive
    
UnaryExpression
    = ("!"|"~"|"+"|"-"|"++"|"--") PropertyExpression                                      -- compose
    | PropertyExpression                                                                  -- derive 

MultiplicativeBinaryExpression
    = UnaryExpression ("*"|"/"|"%") UnaryExpression                                       -- compose
    | UnaryExpression                                                                     -- derive

AdditiveBinaryExpression
    = MultiplicativeBinaryExpression ("+"|"-") MultiplicativeBinaryExpression             -- compose
    | MultiplicativeBinaryExpression                                                      -- derive

BitBinaryExpression
    = AdditiveBinaryExpression ("&"|"|"|"^") AdditiveBinaryExpression                     -- compose
    | AdditiveBinaryExpression                                                            -- derive

CompareBinaryExpression
    = BitBinaryExpression ("=="|"!="|"<="|">="|"<"|">") BitBinaryExpression               -- compose
    | BitBinaryExpression                                                                 -- derive

LogicBinaryExpression
    = CompareBinaryExpression ("&&"|"||") CompareBinaryExpression                         -- compose
    | CompareBinaryExpression                                                             -- derive

TernaryExpression
    = LogicBinaryExpression "?" LogicBinaryExpression ":" LogicBinaryExpression           -- compose
    | LogicBinaryExpression                                                               -- derive

AssignExpression
    = TernaryExpression ("="|"+="|"-="|"*="|"/="|"^="|"|="|"&=") TernaryExpression        -- assign
    | ("var"|"let")? name ":" Type "=" TernaryExpression                                  -- assignHint
    | TernaryExpression                                                                   -- derive

space
    += comment

    
comment
    = "//" (~"\n" any)* &("\n" | end)  -- singleLine
    | "/*" (~"*/" any)* "*/"  -- multiLine

}